## Геокодирование адресов Москвы по данным OpenStreetMap

### Описание проекта

Система геокодирования адресов для города Москва на основе данных OpenStreetMap.
По текстовому адресу (в том числе с опечатками и «человеческими» формами) сервис
находит подходящие здания и возвращает:

- **координаты здания** (широта/долгота);
- **нормализованный адрес** вида `город, улица, номер дома корпус/строение`;
- **оценку релевантности (score 0–1)**, вычисляемую логистической моделью на основе
  схожести текста и координат.

Реализованы:

- **Базовый геокодер** — быстрый поиск по точному/почти точному совпадению улицы и номера.
- **Улучшенный геокодер (Advanced)**:
  - нечеткий поиск улиц (`rapidfuzz`, расстояние Левенштейна по каноническим названиям);
  - нормализация номера дома с поддержкой корпусов/строений/литер (`10 к1`, `2 к2 с1`, `30/2` → `30к2` и т.п.);
  - логистическая модель (scikit‑learn), которая объединяет текстовые и геометрические признаки в итоговый `score` (0–1).

Система ориентирована на:

- устойчивость к опечаткам и вариациям формата адреса;
- корректную обработку корпусов/строений (`к`, `с`, `литера`);
- единый нормализованный текстовый формат адреса;
- воспроизводимую оценку качества (по тексту и координатам);
- простой REST API и удобный веб‑интерфейс для интеграции и ручной проверки.

---

## Нормализованный формат адреса (как проверять)

### Формат

Нормализованный адрес в системе (и в веб‑интерфейсе, и в REST‑ответе) имеет вид:

```text
{город}, {улица}, {номер дома} {корпус} {строение}
```

Примеры итогового нормализованного адреса:

- `Москва, Дорожная улица, 50 к1 с15`
- `Москва, Тверская улица, 10`

- **Город**: полное название (`Москва`).  
- **Улица**: название без сокращений, с полным типом:
  - `ул.` → `улица`
  - `пер.` → `переулок`
  - `пр-т` / `пр-кт` / `просп.` → `проспект`
  - `пл.` → `площадь`
  - `ш.` → `шоссе`
  - `б-р` → `бульвар`
  - `наб.` → `набережная`
  - и т.п.
- **Номер**:
  - основной номер дома: `50`;
  - корпус: `к1`;
  - строение: `с15`;
  - в текстовом виде в ответе всегда выводится как `50 к1 с15`, а в канонической строке для поиска — `50к1с15`.

Порядок слов в названии улицы (например, `Тверская площадь` / `площадь Тверская`) приводится
к единому каноническому виду для поиска, но в выводе используются нормальные человеко‑читаемые
названия без сокращений.

### Устойчивость к входному формату

На вход (в веб‑интерфейсе и в API) можно подавать разные варианты адреса, в том числе не «идеальные»:

- с сокращениями: `Москва, ул. Дорожная, д. 50, к.1, стр.15`, `МКАД, 78-й км, д. 2, к2`;
- с разговорным порядком: `г Москва, Дорожная ул 50 к1 с15`, `Москва Дорожная 50к1с15`;
- частичные адреса по одной улице.

Во всех этих случаях ответ будет приведён к единому человеку‑читаемому виду:

- `Москва, Дорожная улица, 50 к1 с15`
  (ровно в таком формате удобно проверять задание).

Модуль `address_normalizer.py`:
- приводит строку к нижнему регистру, чистит пробелы и запятые;
- разбирает город, улицу и номер (включая несколько уровней: дом, корпус, строение, литера);
- для поиска строит канонические формы улицы и номера;
- для вывода:
  - разворачивает сокращения в полные названия (`ул.` → `улица`, `пер.` → `переулок`, `пр-т` → `проспект` и т.п.);
  - форматирует номер как `номер дома корпус строение` (`50к1с15` → `50 к1 с15`);
  - собирает итоговую строку в формате `город, улица, номер дома корпус строение`.

---

## Структура проекта

```text
rwb/
├── data/
│   ├── central-fed-district-251113.osm.pbf   # Исходный PBF (ЦФО, от организаторов)
│   ├── buildings.osm.pbf                     # PBF с building=* (можно пересоздать)
│   └── moscow_buildings.geojson              # Итоговый слой зданий Москвы
├── src/
│   ├── __init__.py
│   ├── address_normalizer.py                 # Нормализация и парсинг адресов (FIAS‑подобные правила, корпуса/стр. + форматы типа «30/2»)
│   ├── geocoder_base.py                      # Базовый геокодер (точное/почти точное совпадение)
│   ├── geocoder_advanced.py                  # Улучшенный геокодер с нечетким поиском и ML‑скорингом
│   ├── metrics.py                            # Метрики по тексту и координатам
│   ├── api.py                                # REST API + веб‑интерфейс (FastAPI + Starlette)
│   ├── osm_parser.py                         # Обёртка для работы с PBF (через osmium-tool)
│   ├── process_large_geojson.py              # Чанковая обработка больших GeoJSON
│   ├── process_osm_data.py                   # Скрипт полного пайплайна обработки данных
│   ├── example_usage.py                      # Демонстрация работы, расчёт метрик и генерация CSV
│   ├── evaluate_geocoder.py                  # Оффлайн-оценка и подготовка обучающей выборки для скоринга
│   └── train_scoring_model.py                # Обучение логистической модели скоринга
├── static/
│   └── index.html                            # Одностраничный UI: строка поиска + карта (Leaflet, FastAPI)
├── convert_optimized.sh                      # Скрипт PBF → GeoJSON с фильтрацией Москвы
├── CONVERT_OSM.md                            # Подробная инструкция по конвертации/фильтрации OSM
├── requirements.txt
├── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## Установка и запуск

### Локальный запуск

1. **Виртуальное окружение (рекомендуется):**

```bash
python3 -m venv venv
source venv/bin/activate
```

2. **Установка зависимостей:**

```bash
python3 -m pip install --upgrade pip
pip install -r requirements.txt
```

3. **Подготовка данных (здания Москвы):**

- **Вариант A — использовать готовый GeoJSON:**

  Поместите файл с подготовленными зданиями Москвы в:

  ```text
  data/moscow_buildings.geojson
  ```

- **Вариант B — собрать слой из PBF с помощью `convert_optimized.sh`:**

  1) Установите `osmium-tool`:

  ```bash
  # macOS
  brew install osmium-tool

  # Linux
  sudo apt-get install osmium-tool
  ```

  2) Убедитесь, что в `data/` лежит исходный PBF:

  ```text
  data/central-fed-district-251113.osm.pbf
  ```

  3) Запустите:

  ```bash
  ./convert_optimized.sh
  ```

  После успешного завершения в `data/moscow_buildings.geojson` будет готовый слой зданий Москвы.

  Детали альтернативных сценариев (QGIS, ogr2ogr и т.п.) описаны в `CONVERT_OSM.md`.

4. **Запуск REST API и веб‑интерфейса:**

```bash
uvicorn src.api:app --host 0.0.0.0 --port 8000
```

- веб‑интерфейс: `http://localhost:8000/` (или `http://localhost:8000/ui`);
- health‑check: `http://localhost:8000/health`.

### Запуск в Docker

```bash
docker-compose up --build
```

---

## Веб‑интерфейс и REST API

### Веб‑интерфейс (карта + строка поиска)

После запуска сервиса (`uvicorn src.api:app --host 0.0.0.0 --port 8000`) откройте:

- `http://localhost:8000/` или `http://localhost:0.0.0.0/ui`

В веб‑интерфейсе доступны:

- **Строка поиска** с подсказками (например: `Москва, Дорожная улица, 50 к1 с15`, `Москва, Тверская улица, 10`, `Москва, МКАД, 78-й километр, 2 к2`);
- **Переключатель алгоритма**: `Advanced` (нечеткий поиск + ML‑скоринг) и `Base` (быстрый точный поиск);
- **Список кандидатов** с нормализованными адресами, координатами и `score` (0–1);
- **Интерактивная карта (Leaflet)**: клики по результатам центрируют карту и открывают попап с адресом и score.

### REST‑эндпоинт геокодирования

- **POST** `http://localhost:8000/geocode`
- **Тело запроса:**

```json
{
  "address": "Москва, Дорожная улица, 50 к1 с15",
  "algorithm": "advanced",
  "max_results": 5
}
```

- **Пример ответа (усечённый):**

```json
{
  "searched_address": "Москва, Дорожная улица, 50 к1 с15",
  "objects": [
    {
      "locality": "Москва",
      "street": "Дорожная улица",
      "number": "50 к1 с15",
      "lon": 37.6085,
      "lat": 55.7630,
      "score": 0.81
    }
  ]
}
```

---

## Используемые данные и шаги предобработки

### Исходные данные

- PBF файл Центрального Федерального округа из OpenStreetMap (`central-fed-district-251113.osm.pbf`);
- содержит геоданные о зданиях, улицах и адресных атрибутах.

### Предобработка данных

1. **Загрузка OSM данных**: конвертация PBF файла в GeoJSON с помощью готовых инструментов (`osmium-tool`, QGIS) или использование предобработанных данных.
2. **Извлечение зданий**: фильтрация объектов с типом `building`.
3. **Фильтрация по географии**: отбор зданий в границах Москвы (55.5–55.9°N, 37.3–37.9°E).
4. **Извлечение адресных атрибутов**:
   - `addr:city` → `locality`;
   - `addr:street` → `street`;
   - `addr:housenumber` → `number`.
5. **Фильтрация по полноте данных**: оставляем только здания с указанными улицей и номером дома.
6. **Нормализация адресов**: приведение к единому формату с учетом классификатора FIAS.
7. **Сохранение в GeoJSON**: для быстрой загрузки при работе API.

### Нормализация адресов

Нормализация включает:
- приведение к нижнему регистру;
- удаление лишних пробелов;
- обработку сокращений согласно классификатору FIAS;
- парсинг компонентов адреса (населенный пункт, улица, номер дома, корпус, строение).

---

## Алгоритмы геокодирования

### Базовый алгоритм

**Подход**: простое точное совпадение компонентов адреса без продвинутой обработки текста.

**Реализация**:
- нормализация входного адреса и адресов в базе данных;
- канонизация улиц (название + тип) и номеров домов;
- точное совпадение улицы и номера дома;
- при отсутствии точных совпадений — частичное совпадение по улице;
- возврат найденных объектов с `score = 1.0`.

**Особенности**:
- быстрый поиск за счет простой индексации;
- требует довольно точного совпадения компонентов;
- не обрабатывает опечатки и сильные вариации написания.

### Улучшенный алгоритм

**Подход**: использование нечетких метрик, нормализаций и индексации.

**Реализация**:
- нечеткий поиск улиц с использованием расстояния Левенштейна (библиотека `rapidfuzz`) по каноническим названиям;
- пространственная индексация с помощью R-tree для быстрого поиска по координатам;
- нормализация всех компонентов адреса (город, улица, номер, корпус, строение);
- вычисление релевантности (score) логистической моделью на основе:
  - схожести улицы;
  - совпадения номера дома, корпуса и строения;
  - схожести полного адреса;
  - соответствия города;
- ранжирование результатов по убыванию score.

**Дополнительные возможности**:
- функция `geocode_with_location_hint()` для учета геолокации при отборе кандидатов;
- настраиваемые пороги схожести;
- возврат множественных результатов с оценкой релевантности.

**Преимущества**:
- обрабатывает опечатки и вариации написания;
- учитывает корпуса и строения (`к`, `с`);
- выдает результаты в нормализованном формате адреса.

---

## Метрики оценки качества

Реализация метрик находится в `src/metrics.py` (`GeocodingMetrics`).

### Метрика по тексту адреса

Используется нормированная схожесть на основе расстояния Левенштейна:

```text
score = 1 - L(A_pred, A_true) / max(len(A_pred), len(A_true))
```

где:
- `A_pred` — нормализованный предсказанный адрес в формате  
  `"город, улица, номер дома корпус строение"`;
- `A_true` — нормализованный эталонный адрес в том же формате;
- `L(x, y)` — расстояние Левенштейна между строками.

Значение `1` означает полное совпадение, `0` — максимальное различие.

Отдельно реализована функция `levenshtein_distance_raw()` — «сырое»
расстояние Левенштейна, которое используется при анализе датасета и выгрузке в CSV.

### Метрика по координатам

Вычисляется расстояние между предсказанными и эталонными координатами:
- расстояние в метрах (используется библиотека `geopy`);
- нормализованный score:

```text
score = 1.0 - (distance / max_distance_m)
```

Если расстояние больше `max_distance_m`, score обнуляется.

### Комбинированная метрика

Взвешенная сумма текстовой и координатной метрик:

```text
combined_score = text_weight * text_score + coord_weight * coord_score
```

По умолчанию: `text_weight = 0.5`, `coord_weight = 0.5`.

### Оценка на батче адресов

Функция `GeocodingMetrics.evaluate_batch()` считает средние и медианные значения
метрик по набору предсказаний и эталонных адресов (а также p95 по расстоянию).
Пример использования приведён в `src/example_usage.py`:
- выбирается 100 случайных зданий из датасета;
- для каждого формируется запрос и получаются предсказания улучшенного геокодера;
- считается набор метрик и сохраняется детальная таблица в  
  `data/evaluation_addresses.csv` (со статусом `OK/FAIL` для каждого адреса).

---

## Примеры использования

### Через Python API

```python
import geopandas as gpd
from src.geocoder_advanced import AdvancedGeocoder

# Загрузка данных
buildings = gpd.read_file("data/moscow_buildings.geojson")

# Инициализация геокодера
geocoder = AdvancedGeocoder(buildings)

# Геокодирование (вход может быть в произвольной форме)
results = geocoder.geocode("Москва, ул. Тверская, д. 10")

for obj in results:
    print(
        obj["locality"],
        obj["street"],   # уже нормализовано: "Тверская улица"
        obj["number"],   # уже нормализовано: "10", "50 к1 с15" и т.д.
        obj["lat"],
        obj["lon"],
        obj["score"],
    )
```

### Через REST API

```bash
curl -X POST "http://localhost:8000/geocode" \
  -H "Content-Type: application/json" \
  -d '{
    "address": "Москва, Дорожная улица, 50 к1 с15",
    "algorithm": "advanced",
    "max_results": 5
  }'
```

Ответ содержит список объектов с полями:
- `locality` — город;
- `street` — полное название улицы без сокращений;
- `number` — нормализованный номер дома с корпусом/строением (`"50 к1 с15"`);
- `lat`, `lon` — координаты здания;
- `score` — итоговый скоринг результата.

### Запуск примера и расчёт метрик

```bash
python src/example_usage.py
```

Скрипт:
- демонстрирует работу базового и улучшенного геокодеров на нескольких запросах;
- считает метрики (текстовую, по координатам и комбинированную) на одном примере;
- оценивает качество на 100 случайных адресах и сохраняет CSV  
  `data/evaluation_addresses.csv` с детальным разбором.

---

## Технические детали

### Внутреннее представление адреса

Внутри геокодера адрес хранится как набор нормализованных компонент:

- **`locality`** — нормализованное название города (для этого проекта всегда `Москва`);
- **`street_normalized`** — каноническое название улицы:  
  - берётся «основное имя» и тип (`улица`, `площадь`, `шоссе` и т.д.);
  - порядок слов приводится к единому виду (`"Тверская площадь"` и `"площадь Тверская"` → одно и то же имя);
  - все дальнейшие сравнения улиц идут по этой канонической форме;
- **`number_normalized`** — канонический номер дома, корпуса и строения:
  - `"50 к1 с15"` → `"50к1с15"`,
  - `"2 к2 с1"` и `"2 к2 с7"` — разные значения и больше не смешиваются;
- **полный адрес** — строка `"город, улица_канон, д. номер_канон"`, используемая в ML‑скоринге.

При выводе результаты проходят через функцию `normalize_components_for_output()`:
- восстанавливаются полные названия типов (`ул.` → `улица` и т.п.);
- номер форматируется как `"50 к1 с15"` (для человека), а не `"50к1с15`;
- все ответы API уже соответствуют формату проверки.

### Парсинг номеров домов (дом/корпус/строение)

Модуль `address_normalizer.py` реализует детальный разбор номера:

- поддерживаются сложные варианты: `2 к2`, `2 к2 с1`, `10 стр 2`, `10 строение 2`, `10 лит А`;
- основная функция `parse_house_number()` возвращает:
  - `main` — основной номер дома;
  - `extras` — список дополнительных частей `[(тип, номер)]`, где тип — `к` (корпус), `с` (строение), `л` (литера);
- функция `normalize_house_number()` строит каноническую строку:
  - `"2 к2 с1"` → `"2к2с1"`,
  - `"2 к2 с7"` → `"2к2с7"`.

В улучшенном геокодере:
- если канонические номера совпали полностью → максимальная схожесть по номеру (`1.0`);
- если совпал только основной номер (`main`), а корпус/строение различаются → штраф (`≈0.3`);
- если основной номер отличается → номер считается несовпадающим.

Это позволяет корректно отличать разные строения и корпуса одного дома.

### Особые случаи: МКАД, площади и т.п.

Для адресов вида:

- `Москва, МКАД, 78-й километр, 2 к2`  
модуль парсинга делает следующее:
- **последнюю часть** после запятой пытается интерпретировать как номер дома (`"2 к2"` → `"2к2"`),
- всё, что до неё, относится к улице (`"МКАД, 78-й километр"`).

Так мы избегаем ситуации, когда `"78-й километр"` ошибочно попадает в номер дома, и геокодер
получает корректные пары `(улица, номер)`.

Для площадей и других типов улиц:
- `parse_street()` умеет искать тип в начале и в конце строки (`"площадь Тверская"` / `"Тверская площадь"`);
- `canonicalize_street()` строит единый канон имени, поэтому совпадения по площадям, шоссе и др.
становятся стабильными.

### Внутренности улучшенного геокодера

`AdvancedGeocoder` использует несколько уровней оптимизаций:

- **Индексация улиц**:
  - при инициализации строится словарь `street_index`: каноническое имя улицы → список зданий;
  - для запроса сначала считается похожесть по **уникальным** названиям улиц, затем берутся top‑N.
- **Нечеткий поиск улиц**:
  - используется `rapidfuzz.fuzz.ratio` по каноническим названиям;
  - для коротких улиц (≤4 символов без пробелов) поднимается порог схожести, чтобы уменьшить шум;
  - тип улицы (`улица`, `площадь`, `шоссе` и т.д.) даёт небольшой бонус/штраф к схожести.
- **Фильтрация по номеру**:
  - если номер есть в запросе, в кандидаты попадают только здания с совпадающим основным номером;
  - корпус/строение учитываются уже на этапе скоринга.
- **ML‑скоринг**:
  - логистическая модель, обученная оффлайн (`train_scoring_model.py`), использует фичи:
    - схожесть улицы;
    - схожесть номера дома/корпуса/строения;
    - схожесть полного адреса;
    - соответствие города;
  - результатом является `score` в диапазоне `[0, 1]`, по которому сортируются кандидаты.

### Пайплайн оффлайн‑оценки

Скрипт `example_usage.py` реализует простой, но показательный пайплайн:

1. Загружаются здания из `data/moscow_buildings.geojson`.
2. Инициализируются `BaseGeocoder` и `AdvancedGeocoder`.
3. На нескольких фиксированных адресах сравнивается поведение базового и улучшенного алгоритмов.
4. Для одного эталонного адреса считается:
   - текстовая метрика;
   - метрика по координатам;
   - комбинированная метрика.
5. Для **100 случайных адресов**:
   - формируется нормализованный текстовый запрос (с учётом города, улицы и номера);
   - запускается улучшенный геокодер;
   - считаются батчевые метрики через `GeocodingMetrics.evaluate_batch()`;
   - формируется CSV `data/evaluation_addresses.csv` со столбцами:
     - исходный (эталонный) адрес по компонентам;
     - предсказанный адрес и координаты;
     - текстовый score, сырое расстояние Левенштейна;
     - расстояние по координатам, флаги `text_ok` / `coord_ok`;
     - итоговый статус `OK` / `FAIL`.

Этот CSV можно использовать для точечного разбора сложных кейсов (МКАД, площади, корпуса/строения).

### Используемые библиотеки

- **geopandas**: работа с геоданными (загрузка предобработанных GeoJSON файлов);
- **rapidfuzz**: нечеткий поиск и расстояние Левенштейна;
- **rtree**: пространственная индексация;
- **fastapi**: REST API фреймворк;
- **geopy**: вычисление расстояний между координатами;
- **scikit‑learn**: обучение логистической модели скоринга.

### Производительность

- базовый алгоритм: быстрый поиск за счет простой индексации по нормализованным улицам и номерам;
- улучшенный алгоритм:
  - использует R-tree для пространственной индексации;
  - кэширует нормализованные адреса;
  - опирается на предобученную логистическую модель скоринга.

## Авторы

Команда: **Авиационное училище**

