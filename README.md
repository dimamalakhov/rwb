## Геокодирование адресов Москвы по данным OpenStreetMap

### Описание проекта

Система геокодирования адресов для города Москва на основе данных OpenStreetMap.
По текстовому адресу в нормализованном формате система находит здания и возвращает
их координаты и оценку релевантности.

Реализованы:
- **базовый алгоритм** — быстрый поиск по точному/почти точному совпадению улицы и дома;
- **улучшенный алгоритм** — нечеткий поиск + нормализация + ML‑скоринг (логистическая регрессия).

Система ориентирована на:
- устойчивость к опечаткам и вариациям формата адреса;
- корректную обработку корпусов/строений (`к`, `с`, `литера`);
- единый нормализованный текстовый формат адреса;
- воспроизводимую оценку качества (по тексту и координатам);
- простой REST API для интеграции.

---

## Нормализованный формат адреса

### Формат

Нормализованный адрес в системе имеет вид:

```text
{город}, {улица}, {номер дома} {корпус} {строение}
```

Примеры:

- `Москва, Дорожная улица, 50 к1 с15`
- `Москва, Тверская улица, 10`

- **Город**: полное название (`Москва`).  
- **Улица**: название без сокращений, с полным типом:
  - `ул.` → `улица`
  - `пер.` → `переулок`
  - `пр-т` / `пр-кт` → `проспект`
  - `пл.` → `площадь`
  - `ш.` → `шоссе`
  - `б-р` → `бульвар`
  - `наб.` → `набережная`
  и т.п.
- **Номер**:
  - основной номер дома: `50`;
  - корпус: `к1`;
  - строение: `с15`;
  - в текстовом виде выводится как `50 к1 с15`, а в канонической строке для поиска — `50к1с15`.

Порядок слов в названии улицы (например, `Тверская площадь` / `площадь Тверская`) приводится
к единому каноническому виду для поиска, но в выводе используются нормальные человеко‑читаемые
названия без сокращений.

### Устойчивость к входному формату

На вход можно подавать разные варианты адреса:

- с сокращениями: `Москва, ул. Тверская, д. 10`, `МКАД, 78-й километр, 2 к2`;
- с разговорным порядком: `г Москва, Тверская 10`;
- частичные адреса.

Модуль `address_normalizer.py`:
- приводит строку к нижнему регистру, чистит пробелы и запятые;
- разбирает город, улицу и номер (включая несколько уровней: дом, корпус, строение, литера);
- для поиска строит канонические формы улицы и номера;
- для вывода формирует нормализованный адрес в формате, описанном выше.

---

## Структура проекта

```text
rwb/
├── data/
│   ├── central-fed-district-251113.osm.pbf   # Исходный PBF (ЦФО, от организаторов)
│   ├── buildings.osm.pbf                     # PBF с building=* (можно пересоздать)
│   └── moscow_buildings.geojson              # Итоговый слой зданий Москвы
├── src/
│   ├── __init__.py
│   ├── address_normalizer.py                 # Нормализация и парсинг адресов (FIAS‑подобные правила)
│   ├── geocoder_base.py                      # Базовый геокодер
│   ├── geocoder_advanced.py                  # Улучшенный геокодер с ML‑скорингом
│   ├── metrics.py                            # Метрики по тексту и координатам
│   ├── api.py                                # REST API (FastAPI)
│   ├── osm_parser.py                         # Обёртка для работы с PBF (через osmium-tool)
│   ├── process_large_geojson.py              # Чанковая обработка больших GeoJSON
│   ├── process_osm_data.py                   # Скрипт полного пайплайна обработки данных
│   ├── example_usage.py                      # Демонстрация работы и оценка метрик
│   ├── evaluate_geocoder.py                  # Скрипт оффлайн-оценки алгоритмов (используется при обучении)
│   └── train_scoring_model.py                # Оффлайн обучение логистической модели скоринга
├── convert_optimized.sh                      # Скрипт PBF → GeoJSON с фильтрацией Москвы
├── CONVERT_OSM.md                            # Подробная инструкция по конвертации/фильтрации OSM
├── requirements.txt
├── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## Установка и запуск

### Локальный запуск

1. **Виртуальное окружение (рекомендуется):**

```bash
python3 -m venv venv
source venv/bin/activate
```

2. **Установка зависимостей:**

```bash
python3 -m pip install --upgrade pip
pip install -r requirements.txt
```

3. **Подготовка данных (здания Москвы):**

- **Вариант A — использовать готовый GeoJSON:**

  Поместите файл с подготовленными зданиями Москвы в:

  ```text
  data/moscow_buildings.geojson
  ```

- **Вариант B — собрать слой из PBF с помощью `convert_optimized.sh`:**

  1) Установите `osmium-tool`:

  ```bash
  # macOS
  brew install osmium-tool

  # Linux
  sudo apt-get install osmium-tool
  ```

  2) Убедитесь, что в `data/` лежит исходный PBF:

  ```text
  data/central-fed-district-251113.osm.pbf
  ```

  3) Запустите:

  ```bash
  ./convert_optimized.sh
  ```

  После успешного завершения в `data/moscow_buildings.geojson` будет готовый слой зданий Москвы.

  Детали альтернативных сценариев (QGIS, ogr2ogr и т.п.) описаны в `CONVERT_OSM.md`.

4. **Запуск REST API:**

```bash
uvicorn src.api:app --host 0.0.0.0 --port 8000
```

Проверка:

```bash
curl http://localhost:8000/health
```

### Запуск в Docker

```bash
docker-compose up --build
```

---

## API

### Эндпоинт геокодирования

- **POST** `/geocode`
- **Тело запроса:**

```json
{
  "address": "Москва, Дорожная улица, 50 к1 с15",
  "algorithm": "advanced",
  "max_results": 5
}
```

- **Пример ответа:**

```json
{
  "searched_address": "Москва, Дорожная улица, 50 к1 с15",
  "objects": [
    {
      "locality": "Москва",
      "street": "Дорожная улица",
      "number": "50 к1 с15",
      "lon": 37.6085,
      "lat": 55.7630,
      "score": 0.81
    }
  ]
}
```

---

## Используемые данные и шаги предобработки

### Исходные данные

- PBF файл Центрального Федерального округа из OpenStreetMap (`central-fed-district-251113.osm.pbf`);
- содержит геоданные о зданиях, улицах и адресных атрибутах.

### Предобработка данных

1. **Загрузка OSM данных**: конвертация PBF файла в GeoJSON с помощью готовых инструментов (`osmium-tool`, QGIS) или использование предобработанных данных.
2. **Извлечение зданий**: фильтрация объектов с типом `building`.
3. **Фильтрация по географии**: отбор зданий в границах Москвы (55.5–55.9°N, 37.3–37.9°E).
4. **Извлечение адресных атрибутов**:
   - `addr:city` → `locality`;
   - `addr:street` → `street`;
   - `addr:housenumber` → `number`.
5. **Фильтрация по полноте данных**: оставляем только здания с указанными улицей и номером дома.
6. **Нормализация адресов**: приведение к единому формату с учетом классификатора FIAS.
7. **Сохранение в GeoJSON**: для быстрой загрузки при работе API.

### Нормализация адресов

Нормализация включает:
- приведение к нижнему регистру;
- удаление лишних пробелов;
- обработку сокращений согласно классификатору FIAS;
- парсинг компонентов адреса (населенный пункт, улица, номер дома, корпус, строение).

---

## Алгоритмы геокодирования

### Базовый алгоритм

**Подход**: простое точное совпадение компонентов адреса без продвинутой обработки текста.

**Реализация**:
- нормализация входного адреса и адресов в базе данных;
- канонизация улиц (название + тип) и номеров домов;
- точное совпадение улицы и номера дома;
- при отсутствии точных совпадений — частичное совпадение по улице;
- возврат найденных объектов с `score = 1.0`.

**Особенности**:
- быстрый поиск за счет простой индексации;
- требует довольно точного совпадения компонентов;
- не обрабатывает опечатки и сильные вариации написания.

### Улучшенный алгоритм

**Подход**: использование нечетких метрик, нормализаций и индексации.

**Реализация**:
- нечеткий поиск улиц с использованием расстояния Левенштейна (библиотека `rapidfuzz`) по каноническим названиям;
- пространственная индексация с помощью R-tree для быстрого поиска по координатам;
- нормализация всех компонентов адреса (город, улица, номер, корпус, строение);
- вычисление релевантности (score) логистической моделью на основе:
  - схожести улицы;
  - совпадения номера дома, корпуса и строения;
  - схожести полного адреса;
  - соответствия города;
- ранжирование результатов по убыванию score.

**Дополнительные возможности**:
- функция `geocode_with_location_hint()` для учета геолокации при отборе кандидатов;
- настраиваемые пороги схожести;
- возврат множественных результатов с оценкой релевантности.

**Преимущества**:
- обрабатывает опечатки и вариации написания;
- учитывает корпуса и строения (`к`, `с`);
- выдает результаты в нормализованном формате адреса.

---

## Метрики оценки качества

Реализация метрик находится в `src/metrics.py` (`GeocodingMetrics`).

### Метрика по тексту адреса

Используется нормированная схожесть на основе расстояния Левенштейна:

```text
score = 1 - L(A_pred, A_true) / max(len(A_pred), len(A_true))
```

где:
- `A_pred` — нормализованный предсказанный адрес в формате  
  `"город, улица, номер дома корпус строение"`;
- `A_true` — нормализованный эталонный адрес в том же формате;
- `L(x, y)` — расстояние Левенштейна между строками.

Значение `1` означает полное совпадение, `0` — максимальное различие.

Отдельно реализована функция `levenshtein_distance_raw()` — «сырое»
расстояние Левенштейна, которое используется при анализе датасета и выгрузке в CSV.

### Метрика по координатам

Вычисляется расстояние между предсказанными и эталонными координатами:
- расстояние в метрах (используется библиотека `geopy`);
- нормализованный score:

```text
score = 1.0 - (distance / max_distance_m)
```

Если расстояние больше `max_distance_m`, score обнуляется.

### Комбинированная метрика

Взвешенная сумма текстовой и координатной метрик:

```text
combined_score = text_weight * text_score + coord_weight * coord_score
```

По умолчанию: `text_weight = 0.5`, `coord_weight = 0.5`.

### Оценка на батче адресов

Функция `GeocodingMetrics.evaluate_batch()` считает средние и медианные значения
метрик по набору предсказаний и эталонных адресов (а также p95 по расстоянию).
Пример использования приведён в `src/example_usage.py`:
- выбирается 100 случайных зданий из датасета;
- для каждого формируется запрос и получаются предсказания улучшенного геокодера;
- считается набор метрик и сохраняется детальная таблица в  
  `data/evaluation_addresses.csv` (со статусом `OK/FAIL` для каждого адреса).

---

## Примеры использования

### Через Python API

```python
import geopandas as gpd
from src.geocoder_advanced import AdvancedGeocoder

# Загрузка данных
buildings = gpd.read_file("data/moscow_buildings.geojson")

# Инициализация геокодера
geocoder = AdvancedGeocoder(buildings)

# Геокодирование (вход может быть в произвольной форме)
results = geocoder.geocode("Москва, ул. Тверская, д. 10")

for obj in results:
    print(
        obj["locality"],
        obj["street"],   # уже нормализовано: "Тверская улица"
        obj["number"],   # уже нормализовано: "10", "50 к1 с15" и т.д.
        obj["lat"],
        obj["lon"],
        obj["score"],
    )
```

### Через REST API

```bash
curl -X POST "http://localhost:8000/geocode" \
  -H "Content-Type: application/json" \
  -d '{
    "address": "Москва, Дорожная улица, 50 к1 с15",
    "algorithm": "advanced",
    "max_results": 5
  }'
```

Ответ содержит список объектов с полями:
- `locality` — город;
- `street` — полное название улицы без сокращений;
- `number` — нормализованный номер дома с корпусом/строением (`"50 к1 с15"`);
- `lat`, `lon` — координаты здания;
- `score` — итоговый скоринг результата.

### Запуск примера и расчёт метрик

```bash
python src/example_usage.py
```

Скрипт:
- демонстрирует работу базового и улучшенного геокодеров на нескольких запросах;
- считает метрики (текстовую, по координатам и комбинированную) на одном примере;
- оценивает качество на 100 случайных адресах и сохраняет CSV  
  `data/evaluation_addresses.csv` с детальным разбором.

---

## Технические детали

### Используемые библиотеки

- **geopandas**: работа с геоданными (загрузка предобработанных GeoJSON файлов);
- **rapidfuzz**: нечеткий поиск и расстояние Левенштейна;
- **rtree**: пространственная индексация;
- **fastapi**: REST API фреймворк;
- **geopy**: вычисление расстояний между координатами.

### Производительность

- базовый алгоритм: быстрый поиск за счет простой индексации по нормализованным улицам и номерам;
- улучшенный алгоритм:
  - использует R-tree для пространственной индексации;
  - кэширует нормализованные адреса;
  - опирается на предобученную логистическую модель скоринга.

## Авторы

[Ваше имя/команда]

